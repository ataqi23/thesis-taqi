message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load files
source(file = "R/matrices.R")
source(file = "R/eigenvectors.R")
source(file = "R/simulate.R")
source(file = "R/animate.R")
# global parameters
bool_plot <- T
bool_loud <- F
bool_animate <- F
################################
### Step 0: Setup the matrix ###
################################
# Set seed
set.seed(24)
# Set parameters
M <- 2
# Generate matrix
P <- RM_stoch(M, symm = F, sparsity = T)
if(bool_loud){P}
################################
#### Step 1: Get the batch ####
################################
# Set batch parameters
B <- 100
# Create batch
batch <- make_batch(M = M, B = B)
if(bool_loud){head(batch)}
##################################
#### Step 2: Evolve the batch ####
##################################
# Set evolution parameters
steps <- 10
# Evolve and index batch
evolved_batch <- evolve_batch(batch, steps, with_steps = T)
# Index the batch
evolved_batch <- indexed_batch(evolved_batch, steps)
if(bool_loud){head(evolved_batch)}
# use numerical derivatives compenentwise to study convergence
#extr <- extract_evol_array
#b1 <- extr(evolved_batch, 1)
# Extract M (remove time and index columns)
#M <- ncol(curr_array) - 2
# Until generalization for any M, we do this manully for 1 and 2
# append ratios
curr_array <- evolved_batch
r_x1 <- rep(1, nrow(curr_array))
r_x2 <- rep(1, nrow(curr_array))
for(i in 2:nrow(curr_array)){
# Find ratios between one step to the other for each variable
r_x1[i] <- curr_array$x1[i] / curr_array$x1[i - 1]
r_x2[i] <- curr_array$x2[i] / curr_array$x2[i - 1]
}
curr_array <- cbind(curr_array, r_x1, r_x2)
append_ratios <- function(curr_array){
1
}
# Remove first row (degenerate values)
curr_array <- curr_array[2:nrow(curr_array),]
ggplot(data = curr_array, mapping = aes(x = r_x1, y = r_x2, color = V3)) + geom_point()
View(curr_array)
ggplot(data = curr_array, mapping = aes(x = r_x1, y = r_x2, color = time)) + geom_point()
source('~/Developer/thesis-taqi/simulate_ev/R/animate.R')
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load files
source(file = "R/matrices.R")
source(file = "R/eigenvectors.R")
source(file = "R/simulate.R")
source(file = "R/animate.R")
# global parameters
bool_plot <- T
bool_loud <- F
bool_animate <- F
################################
### Step 0: Setup the matrix ###
################################
# Set seed
set.seed(24)
# Set parameters
M <- 2
# Generate matrix
P <- RM_stoch(M, symm = F, sparsity = T)
if(bool_loud){P}
################################
#### Step 1: Get the batch ####
################################
# Set batch parameters
B <- 100
# Create batch
batch <- make_batch(M = M, B = B)
if(bool_loud){head(batch)}
##################################
#### Step 2: Evolve the batch ####
##################################
# Set evolution parameters
steps <- 10
# Evolve and index batch
evolved_batch <- evolve_batch(batch, steps, with_steps = T)
if(bool_loud){head(evolved_batch)}
# use numerical derivatives compenentwise to study convergence
#extr <- extract_evol_array
#b1 <- extr(evolved_batch, 1)
# Extract M (remove time and index columns)
#M <- ncol(curr_array) - 2
# Until generalization for any M, we do this manully for 1 and 2
# append ratios
curr_array <- evolved_batch
r_x1 <- rep(1, nrow(curr_array))
r_x2 <- rep(1, nrow(curr_array))
for(i in 2:nrow(curr_array)){
# Find ratios between one step to the other for each variable
r_x1[i] <- curr_array$x1[i] / curr_array$x1[i - 1]
r_x2[i] <- curr_array$x2[i] / curr_array$x2[i - 1]
}
curr_array <- cbind(curr_array, r_x1, r_x2)
append_ratios <- function(curr_array){
1
}
# Remove first row (degenerate values)
curr_array <- curr_array[2:nrow(curr_array),]
ggplot(data = curr_array, mapping = aes(x = r_x1, y = r_x2, color = time)) + geom_point()
View(curr_array)
source('~/Developer/thesis-taqi/simulate_ev/R/animate.R')
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load files
source(file = "R/matrices.R")
source(file = "R/eigenvectors.R")
source(file = "R/simulate.R")
source(file = "R/animate.R")
# global parameters
bool_plot <- T
bool_loud <- F
bool_animate <- F
################################
### Step 0: Setup the matrix ###
################################
# Set seed
set.seed(24)
# Set parameters
M <- 2
# Generate matrix
P <- RM_stoch(M, symm = F, sparsity = T)
if(bool_loud){P}
################################
#### Step 1: Get the batch ####
################################
# Set batch parameters
B <- 100
# Create batch
batch <- make_batch(M = M, B = B)
if(bool_loud){head(batch)}
##################################
#### Step 2: Evolve the batch ####
##################################
# Set evolution parameters
steps <- 10
# Evolve and index batch
evolved_batch <- evolve_batch(batch, steps, with_steps = T)
if(bool_loud){head(evolved_batch)}
# use numerical derivatives compenentwise to study convergence
#extr <- extract_evol_array
#b1 <- extr(evolved_batch, 1)
# Extract M (remove time and index columns)
#M <- ncol(curr_array) - 2
# Until generalization for any M, we do this manully for 1 and 2
# append ratios
curr_array <- evolved_batch
r_x1 <- rep(1, nrow(curr_array))
r_x2 <- rep(1, nrow(curr_array))
for(i in 2:nrow(curr_array)){
# Find ratios between one step to the other for each variable
r_x1[i] <- curr_array$x1[i] / curr_array$x1[i - 1]
r_x2[i] <- curr_array$x2[i] / curr_array$x2[i - 1]
}
curr_array <- cbind(curr_array, r_x1, r_x2)
append_ratios <- function(curr_array){
1
}
# Remove first row (degenerate values)
curr_array <- curr_array[2:nrow(curr_array),]
ggplot(data = curr_array, mapping = aes(x = r_x1, y = r_x2, color = time)) + geom_point()
View(curr_array)
source('~/Developer/thesis-taqi/simulate_ev/R/animate.R')
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load files
source(file = "R/matrices.R")
source(file = "R/eigenvectors.R")
source(file = "R/simulate.R")
source(file = "R/animate.R")
# global parameters
bool_plot <- T
bool_loud <- F
bool_animate <- F
################################
### Step 0: Setup the matrix ###
################################
# Set seed
set.seed(24)
# Set parameters
M <- 2
# Generate matrix
P <- RM_stoch(M, symm = F, sparsity = T)
if(bool_loud){P}
################################
#### Step 1: Get the batch ####
################################
# Set batch parameters
B <- 100
# Create batch
batch <- make_batch(M = M, B = B)
if(bool_loud){head(batch)}
##################################
#### Step 2: Evolve the batch ####
##################################
# Set evolution parameters
steps <- 10
# Evolve and index batch
evolved_batch <- evolve_batch(batch, steps, with_steps = T)
if(bool_loud){head(evolved_batch)}
# use numerical derivatives compenentwise to study convergence
#b1 <- element_array(evolved_batch, 1)
# Extract M (remove time and index columns)
#M <- ncol(curr_array) - 2
# Until generalization for any M, we do this manully for 1 and 2
# append ratios
curr_array <- evolved_batch
r_x1 <- rep(1, nrow(curr_array))
r_x2 <- rep(1, nrow(curr_array))
for(i in 2:nrow(curr_array)){
# Find ratios between one step to the other for each variable
r_x1[i] <- curr_array$x1[i] / curr_array$x1[i - 1]
r_x2[i] <- curr_array$x2[i] / curr_array$x2[i - 1]
}
curr_array <- cbind(curr_array, r_x1, r_x2)
append_ratios <- function(curr_array){
1
}
# Remove first row (degenerate values)
curr_array <- curr_array[2:nrow(curr_array),]
ggplot(data = curr_array, mapping = aes(x = r_x1, y = r_x2, color = time)) + geom_point()
View(curr_array)
source('~/Developer/thesis-taqi/simulate_ev/R/animate.R')
time_array(evolved_batch, steps)
source('~/Developer/thesis-taqi/simulate_ev/R/animate.R')
evolve_batch[,3]
evolve_batch[,]
evolves_batch[,3]
evolved_batch[,3]
class(evolved_batch[,3])
source('~/Developer/thesis-taqi/simulate_ev/R/animate.R')
time_array(evolved_batch, at_time = 9)
time_array(evolved_batch, at_time = steps)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load files
source(file = "R/matrices.R")
source(file = "R/eigenvectors.R")
source(file = "R/simulate.R")
source(file = "R/animate.R")
# global parameters
bool_plot <- T
bool_loud <- F
bool_animate <- F
################################
### Step 0: Setup the matrix ###
################################
# Set seed
set.seed(24)
# Set parameters
M <- 2
# Generate matrix
P <- RM_stoch(M, symm = F, sparsity = T)
if(bool_loud){P}
################################
#### Step 1: Get the batch ####
################################
# Set batch parameters
B <- 100
# Create batch
batch <- make_batch(M = M, B = B)
if(bool_loud){head(batch)}
##################################
#### Step 2: Evolve the batch ####
##################################
# Set evolution parameters
steps <- 10
# Evolve and index batch
evolved_batch <- evolve_batch(batch, steps, with_steps = T)
if(bool_loud){head(evolved_batch)}
# use numerical derivatives compenentwise to study convergence
#b1 <- element_array(evolved_batch, 1)
# Extract M (remove time and index columns)
#M <- ncol(curr_array) - 2
# Until generalization for any M, we do this manully for 1 and 2
# append ratios
curr_array <- evolved_batch
r_x1 <- rep(1, nrow(curr_array))
r_x2 <- rep(1, nrow(curr_array))
for(i in 2:nrow(curr_array)){
# Find ratios between one step to the other for each variable
r_x1[i] <- curr_array$x1[i] / curr_array$x1[i - 1]
r_x2[i] <- curr_array$x2[i] / curr_array$x2[i - 1]
}
curr_array <- cbind(curr_array, r_x1, r_x2)
append_ratios <- function(curr_array){
1
}
# Remove first row (degenerate values)
curr_array <- curr_array[2:nrow(curr_array),]
time_array(curr_array, at_time = steps)
ggplot(data = curr_array, mapping = aes(x = r_x1, y = r_x2, color = time)) + geom_point()
View(curr_array)
curr_array <- time_array(curr_array, at_time = steps)
View(curr_array)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load files
source(file = "R/matrices.R")
source(file = "R/eigenvectors.R")
source(file = "R/simulate.R")
source(file = "R/animate.R")
# global parameters
bool_plot <- T
bool_loud <- F
bool_animate <- F
################################
### Step 0: Setup the matrix ###
################################
# Set seed
set.seed(24)
# Set parameters
M <- 2
# Generate matrix
P <- RM_stoch(M, symm = F, sparsity = T)
if(bool_loud){P}
################################
#### Step 1: Get the batch ####
################################
# Set batch parameters
B <- 100
# Create batch
batch <- make_batch(M = M, B = B)
if(bool_loud){head(batch)}
##################################
#### Step 2: Evolve the batch ####
##################################
# Set evolution parameters
steps <- 50
# Evolve and index batch
evolved_batch <- evolve_batch(batch, steps, with_steps = T)
if(bool_loud){head(evolved_batch)}
# use numerical derivatives compenentwise to study convergence
#b1 <- element_array(evolved_batch, 1)
# Extract M (remove time and index columns)
#M <- ncol(curr_array) - 2
# Until generalization for any M, we do this manully for 1 and 2
# append ratios
curr_array <- evolved_batch
r_x1 <- rep(1, nrow(curr_array))
r_x2 <- rep(1, nrow(curr_array))
for(i in 2:nrow(curr_array)){
# Find ratios between one step to the other for each variable
r_x1[i] <- curr_array$x1[i] / curr_array$x1[i - 1]
r_x2[i] <- curr_array$x2[i] / curr_array$x2[i - 1]
}
curr_array <- cbind(curr_array, r_x1, r_x2)
append_ratios <- function(curr_array){
1
}
# Remove first row (degenerate values)
curr_array <- curr_array[2:nrow(curr_array),]
curr_array <- time_array(curr_array, at_time = steps)
ggplot(data = curr_array, mapping = aes(x = r_x1, y = r_x2, color = time)) + geom_point()
curr_array <- time_array(curr_array, at_time = steps)
View(curr_array)
ggplot(data = curr_array, mapping = aes(x = r_x1, y = r_x2, color = time)) + geom_point()
View(P)
################################
### Step 0: Setup the matrix ###
################################
# Set seed
set.seed(25)
# Set parameters
M <- 2
# Generate matrix
P <- RM_stoch(M, symm = F, sparsity = T)
if(bool_loud){P}
################################
#### Step 1: Get the batch ####
################################
# Set batch parameters
B <- 100
# Create batch
batch <- make_batch(M = M, B = B)
if(bool_loud){head(batch)}
##################################
#### Step 2: Evolve the batch ####
##################################
# Set evolution parameters
steps <- 50
# Evolve and index batch
evolved_batch <- evolve_batch(batch, steps, with_steps = T)
if(bool_loud){head(evolved_batch)}
# use numerical derivatives compenentwise to study convergence
#b1 <- element_array(evolved_batch, 1)
# Extract M (remove time and index columns)
#M <- ncol(curr_array) - 2
# Until generalization for any M, we do this manully for 1 and 2
# append ratios
curr_array <- evolved_batch
r_x1 <- rep(1, nrow(curr_array))
r_x2 <- rep(1, nrow(curr_array))
for(i in 2:nrow(curr_array)){
# Find ratios between one step to the other for each variable
r_x1[i] <- curr_array$x1[i] / curr_array$x1[i - 1]
r_x2[i] <- curr_array$x2[i] / curr_array$x2[i - 1]
}
curr_array <- cbind(curr_array, r_x1, r_x2)
append_ratios <- function(curr_array){
1
}
# Remove first row (degenerate values)
curr_array <- curr_array[2:nrow(curr_array),]
################################
### Step 0: Setup the matrix ###
################################
# Set seed
set.seed(25)
# Set parameters
M <- 2
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bool_loud){P}
################################
#### Step 1: Get the batch ####
################################
# Set batch parameters
B <- 100
# Create batch
batch <- make_batch(M = M, B = B)
if(bool_loud){head(batch)}
##################################
#### Step 2: Evolve the batch ####
##################################
# Set evolution parameters
steps <- 50
# Evolve and index batch
evolved_batch <- evolve_batch(batch, steps, with_steps = T)
if(bool_loud){head(evolved_batch)}
# use numerical derivatives compenentwise to study convergence
#b1 <- element_array(evolved_batch, 1)
# Extract M (remove time and index columns)
#M <- ncol(curr_array) - 2
# Until generalization for any M, we do this manully for 1 and 2
# append ratios
curr_array <- evolved_batch
r_x1 <- rep(1, nrow(curr_array))
r_x2 <- rep(1, nrow(curr_array))
for(i in 2:nrow(curr_array)){
# Find ratios between one step to the other for each variable
r_x1[i] <- curr_array$x1[i] / curr_array$x1[i - 1]
r_x2[i] <- curr_array$x2[i] / curr_array$x2[i - 1]
}
curr_array <- cbind(curr_array, r_x1, r_x2)
append_ratios <- function(curr_array){
1
}
# Remove first row (degenerate values)
curr_array <- curr_array[2:nrow(curr_array),]
ggplot(data = curr_array, mapping = aes(x = r_x1, y = r_x2, color = time)) + geom_point()
View(curr_array)
curr_array <- time_array(curr_array, at_time = steps)
View(curr_array)
