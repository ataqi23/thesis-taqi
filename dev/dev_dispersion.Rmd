---
title: "Developer"
author: "Taqi"
date: "3/9/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("../R/header.R")
.src(1)
```

```{r}
# Some random matrices and ensembles
P <- RM_norm(5, symm = T)
ens <- RME_unif(3, min = 0, max = 1, size = 5)
```

```{r}
# Pair schema
# The largest pair scheme; Largest and second largest
pairs_12 <- data.frame(i = 1, j = 2)
# The consecutive-value scheme (Sufficient such that no linear combiantions of the diseprsion metric exists); one apart
# The triangular pair schema (for symmetric dispersion metrics); essentially all the combinations
# The antisymmetric pair scheme (for assymetric dispersion metrics); essentially all the permutations  
```

```{r}
dispersion <- function(array, norm = 1, pairs = NA, digits = 3){
  # Array is a matrix; call function returning dispersion for singleton matrix
  if(class(array) == "matrix"){.dispersion_matrix(array, norm, pairs, digits)}
  # Array is an ensemble; recursively row binding each matrix's dispersions
  else if(class(array) == "list"){
    if(class(pairs) == "logical"){pairs <- .unique_pairs(nrow(array[[1]]))} # Compute pairs to avoid computational waste and pass as argument
    purrr::map_dfr(.x = array, .f = .dispersion_matrix, norm, pairs, digits)
  }
}

# Find the eigenvalue dispersions for a given matrix
.dispersion_matrix <- function(P, norm = 1, pairs = NA, digits = 3){
  #eigenvalues <- .sort_norm(eigen(P)$values) # Get the eigenvalues of a matrix
  eigenvalues <- spectrum(P)
  N <- nrow(P) # Get matrix dimension
  # If uninitialized for the ensemble, enumerate unique pairs of N eigenvalues
  if(class(pairs) == "logical"){idx_pairs <- .unique_pairs(N)} else{idx_pairs <- pairs} # Otherwise, read in pre-computed values
  # Generate norm function argument (Euclidean or Beta norm)
  norm_fn <- function(x){(abs(x))^norm} 
  purrr::map2_dfr(idx_pairs[,1], idx_pairs[,2], .resolve_dispersion, eigenvalues, norm_fn, digits)
}
```

```{r}
# Read and parse a dispersion observation between eigenvalue i and j.
.resolve_dispersion <- function(i, j, eigenvalues, norm_fn, digits){
  disp <- data.frame(i = i, j = j) # Initialize dispersion dataframe by adding order of eigenvalues compared
  disp$eig_i <- .read_eigenvalue(i, eigenvalues); disp$eig_j <- .read_eigenvalue(j, eigenvalues) # Add the eigenvalues
  disp$id_diff <- disp$eig_j - disp$eig_i # Get the identity difference dispersion metric
  disp$id_diff_norm <- norm_fn(disp$id_diff) # Take the norm of the difference
  disp$abs_diff <- norm_fn(disp$eig_j) - norm_fn(disp$eig_i) # Compute the difference of absolutes w.r.t. norm function (Euclidean or beta)
  disp <- round(disp, digits) # Round digits
  disp$orderDiff_ji <- disp$j - disp$i
  disp # Return resolved dispersion observation
}

# Enumerate the unique pairs given N items; ## Add lower or upper triangle argument, need to create binary lambdas; <(x,y) and >(x,y)
.unique_pairs <- function(N){
  is <- do.call("c",map(1:N, function(i){rep(i,N)}))
  js <- rep(1:N, N)
  do.call("rbind",purrr::map2(is, js, .f = function(i, j){if(i > j){c(i = i, j = j)}}))
}
```

```{r}
.dispersion_matrix(P)
```

