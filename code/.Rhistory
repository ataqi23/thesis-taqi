vals <- matrix(rep(NA, (M+1) * it), ncol = (M+1))
# rename the columns
str_vec <- rep(NA, M)
for(i in 1:M){str_vec[i] = paste("x",i,sep="")}
colnames(vals) <- c("n",str_vec)
# evolve pi
for(i in 1:it){
vals[i, ] = c(i, pi %*% matrix.power(P,i))
}
#store the values in a dataframe
vals_ <- data.frame(vals) # store indices as base df in case they are needed
vals <- subset(vals_, select = -c(n))
vals
}
distance <- function(pi,ref_dist){
#plot difference from a reference/stationary distribution
diff <- rbind(evolve(pi),ref_dist)
dist_vec <- rep(0, it)
for(i in 1:it){
curr_dist <- stats::dist(diff[c(i,it+1),], method = "euclidean")
dist_vec[i] <- curr_dist
}
data.frame(dist_vec)
}
plot_d <- function(init,ref){
dist_vec <- distance(init,ref)
dist_plot <- ggplot(dist_vec, mapping = aes(x = 1:it, y = dist_vec)) +
geom_point(color = col_str) + geom_line(color = col_str) +
labs(x = "n", y = "Euclidean Distance")
dist_plot
}
evol <- evolve(init, P)
pi <- r_zeros(M)
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(ggfortify)
library(matrixcalc)
library(zeallot)
# Load files
source(file = "R/matrices.R")
source(file = "R/eigenvectors.R")
source(file = "R/eigenmetrics.R")
bool_plot <- T
bool_loud <- F
M <- 10
set.seed(23)
M <- 3
P <- RM_stoch(M,row_fn = r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,1] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
evolve <- function(pi, P){
# simulate and record evolution of pi
vals <- matrix(rep(NA, (M+1) * it), ncol = (M+1))
# rename the columns
str_vec <- rep(NA, M)
for(i in 1:M){str_vec[i] = paste("x",i,sep="")}
colnames(vals) <- c("n",str_vec)
# evolve pi
for(i in 1:it){
vals[i, ] = c(i, pi %*% matrix.power(P,i))
}
#store the values in a dataframe
vals_ <- data.frame(vals) # store indices as base df in case they are needed
vals <- subset(vals_, select = -c(n))
vals
}
distance <- function(pi,ref_dist){
#plot difference from a reference/stationary distribution
diff <- rbind(evolve(pi),ref_dist)
dist_vec <- rep(0, it)
for(i in 1:it){
curr_dist <- stats::dist(diff[c(i,it+1),], method = "euclidean")
dist_vec[i] <- curr_dist
}
data.frame(dist_vec)
}
plot_d <- function(init,ref){
dist_vec <- distance(init,ref)
dist_plot <- ggplot(dist_vec, mapping = aes(x = 1:it, y = dist_vec)) +
geom_point(color = col_str) + geom_line(color = col_str) +
labs(x = "n", y = "Euclidean Distance")
dist_plot
}
pi <- r_zeros(M)
evol <- evolve(pi, P)
#dist_vec <- distance(init,st)
View(evol)
evolve <- function(pi, P, steps){
steps <- it
# simulate and record evolution of pi
vals <- matrix(rep(NA, (M+1) * it), ncol = (M+1))
# rename the columns
str_vec <- rep(NA, M)
for(i in 1:M){str_vec[i] = paste("x",i,sep="")}
colnames(vals) <- c("n",str_vec)
# evolve pi
for(i in 1:it){
vals[i, ] = c(i, pi %*% matrix.power(P,i))
}
#store the values in a dataframe
vals_ <- data.frame(vals) # store indices as base df in case they are needed
vals <- subset(vals_, select = -c(n))
vals
}
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
View(evol)
evolve <- function(pi, P, steps){
steps <- it
# simulate and record evolution of pi
vals <- matrix(rep(NA, (M+1) * it), ncol = (M+1))
# rename the columns
str_vec <- rep(NA, M)
for(i in 1:M){str_vec[i] = paste("x",i,sep="")}
colnames(vals) <- c("n",str_vec)
# evolve pi
for(i in 1:it){
vals[i, ] = c(i, pi %*% matrix.power(P,i))
}
#store the values in a dataframe
vals_ <- data.frame(vals) # store indices as base df in case they are needed
vals <- subset(vals_, select = -c(n))
vals
}
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
View(evol)
evolve <- function(pi, P, steps){
steps <- it
# simulate and record evolution of pi
vals <- matrix(rep(NA, (M+1) * it), ncol = (M+1))
# rename the columns
str_vec <- rep(NA, M)
for(i in 1:M){str_vec[i] = paste("x",i,sep="")}
colnames(vals) <- c("n",str_vec)
# evolve pi
for(i in 1:it){
vals[i, ] = c(i, pi %*% matrix.power(P,i))
}
#store the values in a dataframe
vals_ <- data.frame(vals) # store indices as base df in case they are needed
vals <- subset(vals_, select = -c(n))
vals
}
distance <- function(pi,ref_dist){
#plot difference from a reference/stationary distribution
diff <- rbind(evolve(pi),ref_dist)
dist_vec <- rep(0, it)
for(i in 1:it){
curr_dist <- stats::dist(diff[c(i,it+1),], method = "euclidean")
dist_vec[i] <- curr_dist
}
data.frame(dist_vec)
}
plot_d <- function(init,ref){
dist_vec <- distance(init,ref)
dist_plot <- ggplot(dist_vec, mapping = aes(x = 1:it, y = dist_vec)) +
geom_point(color = col_str) + geom_line(color = col_str) +
labs(x = "n", y = "Euclidean Distance")
dist_plot
}
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
View(evol)
View(P)
ggplot(evol) + geom_point(mapping = aes(x = evol$x1))
ggplot(evol) + geom_point(mapping = aes(x = evol$x1, y = evol$x2))
set.seed(23)
M <- 3
P <- RM_stoch(M,row_fn = r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,1] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
View(eigen_vecs)
View(eigen_vecs)
set.seed(23)
M <- 3
P <- RM_stoch(M,row_fn = r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
View(st)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
View(evol)
set.seed(28)
M <- 3
P <- RM_stoch(M,row_fn = r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
View(st)
ggplot(evol) + geom_point(mapping = aes(x = evol$x1, y = evol$x2))
ggplot(evol) + geom_point(mapping = aes(x = evol$x1, y = evol$x2)) + geom_point(mapping = aes(x = evol$x1, y = evol$x3))
set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) + geom_point(mapping = aes(x = evol$x1, y = evol$x2)) + geom_point(mapping = aes(x = evol$x1, y = evol$x3))
ggplot(evol) + geom_point(mapping = aes(x = evol$x1, y = evol$x2)) + geom_point(mapping = aes(x = evol$x1, y = evol$x3), color = "blue")
ggplot(evol) + geom_point(mapping = aes(x = evol$x1, y = evol$x2), color = "red") + geom_point(mapping = aes(x = evol$x1, y = evol$x3), color = "blue")
set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) + geom_point(mapping = aes(x = evol$x1, y = evol$x2), color = "red") + geom_point(mapping = aes(x = evol$x1, y = evol$x3), color = "blue")
ggplot(evol) + geom_point(mapping = aes(x = x1, y = x2), color = "red") + geom_point(mapping = aes(x = x1, y = x3), color = "blue")
View(st)
View(P)
set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) + geom_point(mapping = aes(x = x1, y = x2), color = "red") + geom_point(mapping = aes(x = x1, y = x3), color = "blue")
View(evol)
evolve <- function(pi, P, steps){
steps <- it
# simulate and record evolution of pi
vals <- matrix(rep(NA, (M+1) * it), ncol = (M+1))
# rename the columns
str_vec <- rep(NA, M)
for(i in 1:M){str_vec[i] = paste("x",i,sep="")}
colnames(vals) <- c("n",str_vec)
# evolve pi
for(i in 1:it){
vals[i, ] = c(i, pi %*% matrix.power(P,i))
}
#store the values in a dataframe
vals_ <- data.frame(vals) # store indices as base df in case they are needed
vals <- subset(vals_, select = -c(n))
rbind(pi,vals)
}
distance <- function(pi,ref_dist){
#plot difference from a reference/stationary distribution
diff <- rbind(evolve(pi),ref_dist)
dist_vec <- rep(0, it)
for(i in 1:it){
curr_dist <- stats::dist(diff[c(i,it+1),], method = "euclidean")
dist_vec[i] <- curr_dist
}
data.frame(dist_vec)
}
plot_d <- function(init,ref){
dist_vec <- distance(init,ref)
dist_plot <- ggplot(dist_vec, mapping = aes(x = 1:it, y = dist_vec)) +
geom_point(color = col_str) + geom_line(color = col_str) +
labs(x = "n", y = "Euclidean Distance")
dist_plot
}
set.seed(28)
M <- 3
P <- RM_stoch(M,row_fn = r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) + geom_point(mapping = aes(x = x1, y = x2), color = "red") + geom_point(mapping = aes(x = x1, y = x3), color = "blue")
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(ggfortify)
library(matrixcalc)
library(zeallot)
# Load files
source(file = "R/matrices.R")
source(file = "R/eigenvectors.R")
source(file = "R/eigenmetrics.R")
bool_plot <- T
bool_loud <- F
evolve <- function(pi, P, steps){
steps <- it
# simulate and record evolution of pi
vals <- matrix(rep(NA, (M+1) * it), ncol = (M+1))
# rename the columns
str_vec <- rep(NA, M)
for(i in 1:M){str_vec[i] = paste("x",i,sep="")}
colnames(vals) <- c("n",str_vec)
# evolve pi
for(i in 1:it){
vals[i, ] = c(i, pi %*% matrix.power(P,i))
}
#store the values in a dataframe
vals_ <- data.frame(vals) # store indices as base df in case they are needed
vals <- subset(vals_, select = -c(n))
rbind(pi,vals)
}
distance <- function(pi,ref_dist){
#plot difference from a reference/stationary distribution
diff <- rbind(evolve(pi),ref_dist)
dist_vec <- rep(0, it)
for(i in 1:it){
curr_dist <- stats::dist(diff[c(i,it+1),], method = "euclidean")
dist_vec[i] <- curr_dist
}
data.frame(dist_vec)
}
plot_d <- function(init,ref){
dist_vec <- distance(init,ref)
dist_plot <- ggplot(dist_vec, mapping = aes(x = 1:it, y = dist_vec)) +
geom_point(color = col_str) + geom_line(color = col_str) +
labs(x = "n", y = "Euclidean Distance")
dist_plot
}
set.seed(28)
M <- 3
P <- RM_stoch(M,row_fn = r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) + geom_point(mapping = aes(x = x1, y = x2), color = "red") + geom_point(mapping = aes(x = x1, y = x3), color = "blue")
M <- 3
P <- RM_stoch(M,row_fn = r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
M <- 3
P <- RM_stoch(M,row_fn = r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) + geom_point(mapping = aes(x = x1, y = x2), color = "red") + geom_point(mapping = aes(x = x1, y = x3), color = "blue")
View(evol)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) + geom_point(mapping = aes(x = x1, y = x2), color = "red") + geom_point(mapping = aes(x = x1, y = x3), color = "blue")
M <- 3
P <- RM_symm_norm(M,mu = 0, sd = 1)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) + geom_point(mapping = aes(x = x1, y = x2), color = "red") + geom_point(mapping = aes(x = x1, y = x3), color = "blue")
View(P)
M <- 3
P <- RM_symm_stoch(M, r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) + geom_point(mapping = aes(x = x1, y = x2), color = "red") + geom_point(mapping = aes(x = x1, y = x3), color = "blue")
View(st)
View(P)
M <- 3
P <- RM_symm_stoch(M, r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
View(P)
ggplot(evol) +
geom_point(mapping = aes(x = x1, y = x2), color = "red") +
geom_point(mapping = aes(x = x1, y = x3), color = "blue") +
geom_point(mapping = aes(x = x1, y = x4), color = "blue")
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(ggfortify)
library(matrixcalc)
library(zeallot)
# Load files
source(file = "R/matrices.R")
source(file = "R/eigenvectors.R")
source(file = "R/eigenmetrics.R")
bool_plot <- T
bool_loud <- F
evolve <- function(pi, P, steps){
steps <- it
# simulate and record evolution of pi
vals <- matrix(rep(NA, (M+1) * it), ncol = (M+1))
# rename the columns
str_vec <- rep(NA, M)
for(i in 1:M){str_vec[i] = paste("x",i,sep="")}
colnames(vals) <- c("n",str_vec)
# evolve pi
for(i in 1:it){
vals[i, ] = c(i, pi %*% matrix.power(P,i))
}
#store the values in a dataframe
vals_ <- data.frame(vals) # store indices as base df in case they are needed
vals <- subset(vals_, select = -c(n))
rbind(pi,vals)
}
distance <- function(pi,ref_dist){
#plot difference from a reference/stationary distribution
diff <- rbind(evolve(pi),ref_dist)
dist_vec <- rep(0, it)
for(i in 1:it){
curr_dist <- stats::dist(diff[c(i,it+1),], method = "euclidean")
dist_vec[i] <- curr_dist
}
data.frame(dist_vec)
}
plot_d <- function(init,ref){
dist_vec <- distance(init,ref)
dist_plot <- ggplot(dist_vec, mapping = aes(x = 1:it, y = dist_vec)) +
geom_point(color = col_str) + geom_line(color = col_str) +
labs(x = "n", y = "Euclidean Distance")
dist_plot
}
M <- 4
P <- RM_symm_stoch(M, r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) +
geom_point(mapping = aes(x = x1, y = x2), color = "red") +
geom_point(mapping = aes(x = x1, y = x3), color = "blue") +
geom_point(mapping = aes(x = x1, y = x4), color = "green")
M <- 4
P <- RM_symm_stoch(M, r_zeros)
eigen_vecs <- data.frame(eigen(P)[2])
st <- eigen_vecs[1,] # choose reference vector to find distance from
it <- 30 # number of iterations of transition matrix
View(P)
#set.seed(23)
pi <- r_zeros(M)
evol <- evolve(pi, P, steps = 10)
#dist_vec <- distance(init,st)
ggplot(evol) +
geom_point(mapping = aes(x = x1, y = x2), color = "red") +
geom_point(mapping = aes(x = x1, y = x3), color = "blue") +
geom_point(mapping = aes(x = x1, y = x4), color = "green")
View(evol)
