message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load files
source(file = "../R/matrices_n.R")
source(file = "../R/eigenvectors.R")
source(file = "../R/simulate.R")
source(file = "../R/animate.R")
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load files
source(file = "../R/matrices_n.R")
source(file = "../R/eigenvectors.R")
source(file = "../R/simulate.R")
source(file = "../R/animate.R")
bloud <- F
bplot <- F
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
View(P)
batchP <- run_batch(P, 4, steps = 30)
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load files
source(file = "../R/matrices_n.R")
source(file = "../R/eigenvectors.R")
source(file = "../R/simulate.R")
source(file = "../R/animate.R")
bloud <- F
bplot <- F
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
batchP <- run_batch(P, 4, steps = 30)
source('~/Developer/thesis-taqi/R/animate.R')
source('~/Developer/thesis-taqi/R/simulate.R')
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
source('~/Developer/thesis-taqi/code/../R/header.R')
source('~/Developer/thesis-taqi/code/../R/header.R')
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
rep(4,5)
rep(4,5)/rep(2,5)
rep(4,5)/rep(3,5)
rep(4,5)/c(rep(3,4),1)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
source('~/Developer/thesis-taqi/R/simulate.R')
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
source('~/Developer/thesis-taqi/R/analyze.R')
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
source('~/Developer/thesis-taqi/R/simulate.R')
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
source('~/Developer/thesis-taqi/R/simulate.R')
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
source('~/Developer/thesis-taqi/R/simulate.R')
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
source('~/Developer/thesis-taqi/R/simulate.R')
batchP <- run_batch(P, 4, steps = 30)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
source('~/Developer/thesis-taqi/R/simulate.R')
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
View(batchP)
View(batchP)
View(batchP)
element_ratios <- function(curr_element){
# Get number of elements and steps
M <- ncol(curr_element) - 2
steps <- nrow(curr_element)
# Initalize the stack
ratio_stack <- rep(NA, M)
for(i in 2:steps){
# Get ratio of rows from current step
curr_ratios <- curr_element[i, 1:M]/curr_element[i-1, 1:M]
# Stack
ratio_stack <- rbind(ratio_stack, curr_ratios)
}
ratio_stack
}
element_ratios <- function(curr_element){
# Get number of elements and steps
M <- ncol(curr_element) - 2
steps <- nrow(curr_element)
# Initalize the stack
ratio_stack <- rep(NA, M)
for(i in 2:steps){
# Get ratio of rows from current step
curr_ratios <- curr_element[i, 1:M]/curr_element[i-1, 1:M]
# Stack
ratio_stack <- rbind(ratio_stack, curr_ratios)
}
ratio_stack
}
B <- 4
evolved_batch <- batchP
steps <- 30
# Assuming two non-element columns (time, index) initialize the ratio stack
r_stack <- element_array(evolved_batch, 1)
for(i in 2:B){
curr_ratios <- element_ratios(element_array(evolved_batch, i))
r_stack <- cbind(r_stack, curr_ratios)
}
r_stack
View(curr_ratios)
View(r_stack)
B <- 4
evolved_batch <- batchP
steps <- 30
# Assuming two non-element columns (time, index) initialize the ratio stack
r_stack <- element_array(evolved_batch, 1)
for(i in 2:B){
curr_ratios <- element_ratios(element_array(evolved_batch, i))
r_stack <- rbind(r_stack, curr_ratios)
}
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
#### GENERALIZE BY DIVIDING COLUMN RANGE BY PREV ROW
#### Create ratio stack
#### Ratio row i for i in 2:B = evol[1:ncol(P)-1, i]/evol[1:ncol(P)-1, i-1] (no time col)
#### Append ratio stack
#### cbind(evol, ratios)
element_ratios <- function(curr_element){
# Get number of elements and steps
M <- ncol(curr_element) - 2
steps <- nrow(curr_element)
# Initalize the stack
ratio_stack <- rep(NA, M)
for(i in 2:steps){
# Get ratio of rows from current step
curr_ratios <- curr_element[i, 1:M]/curr_element[i-1, 1:M]
# Stack
ratio_stack <- rbind(ratio_stack, curr_ratios)
}
ratio_stack
}
B <- 4
evolved_batch <- batchP
steps <- 30
# Assuming two non-element columns (time, index) initialize the ratio stack
r_stack <- element_array(evolved_batch, 1)
for(i in 2:B){
curr_ratios <- element_ratios(element_array(evolved_batch, i))
r_stack <- rbind(r_stack, curr_ratios)
}
View(r_stack)
B <- 4
evolved_batch <- batchP
steps <- 30
# Assuming two non-element columns (time, index) initialize the ratio stack
r_stack <- element_ratios(element_array(evolved_batch, 1))
for(i in 2:B){
curr_ratios <- element_ratios(element_array(evolved_batch, i))
r_stack <- rbind(r_stack, curr_ratios)
}
r_stack
View(r_stack)
View(r_stack)
append_ratios <- function(evolved_batch){
# Assuming two non-element columns (time, index) initialize the ratio stack
r_stack <- element_ratios(element_array(evolved_batch, 1))
for(i in 2:B){
curr_ratios <- element_ratios(element_array(evolved_batch, i))
r_stack <- rbind(r_stack, curr_ratios)
}
cbind(evolved_batch, r_stack)
}
source('~/Developer/thesis-taqi/R/simulate.R')
source('~/Developer/thesis-taqi/R/analyze.R')
source('~/Developer/thesis-taqi/R/simulate.R')
batchP <- run_batch(P, 4, steps = 30)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
View(P)
batchP
source('~/Developer/thesis-taqi/R/analyze.R')
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
batchP <- run_batch(P, 4, steps = 30)
View(batchP)
last <- time_array(batchP, 30)
View(last)
# Set parameters
B <- 100
steps <- 50
# Evolve batch
evolved_batch <- run_batch(P, B, steps)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
# Set parameters
B <- 100
steps <- 50
# Evolve batch
evolved_batch <- run_batch(P, B, steps)
# Find final elements
last <- time_array(evolved_batch, steps)
View(last)
View(evolved_batch)
# Set parameters
B <- 100
steps <- 50
# Evolve batch
evolved_batch <- run_batch(P, B, steps)
# Find final elements
last <- time_array(evolved_batch, at_time = 50)
View(evolved_batch)
View(evolved_batch)
View(last)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_stoch(M, symm = T, sparsity = F)
if(bloud){P}
# Set parameters
B <- 100
steps <- 50
# Evolve batch
evolved_batch <- run_batch(P, B, steps)
# Find final elements
last <- time_array(evolved_batch, at_time = 50)
View(last)
View(evolved_batch)
# Find final elements
last <- time_array(evolved_batch, at_time = 25)
View(last)
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_normal(M, normal_args = c(0,1))
if(bloud){P}
# Set parameters
B <- 100
steps <- 50
# Evolve batch
evolved_batch <- run_batch(P, B, steps)
# Find final elements
last <- time_array(evolved_batch, at_time = 25)
View(last)
# Set parameters
B <- 100
steps <- 5
# Evolve batch
evolved_batch <- run_batch(P, B, steps)
# Find final elements
last <- time_array(evolved_batch, at_time = 25)
View(last)
eigen_frame(P)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(tidyverse)
library(knitr)
library(patchwork)
library(gridExtra)
library(matrixcalc)
library(numDeriv)
# Load header
source("../R/header.R")
# Set seed
#set.seed(23)
# Set parameters
M <- 7
# Generate matrix
P <- RM_normal(M, normal_args = c(0,1))
if(bloud){P}
# Set parameters
B <- 100
steps <- 5
# Evolve batch
evolved_batch <- run_batch(P, B, steps)
eigen_frame(P)
# Find final elements
last <- time_array(evolved_batch, at_time = 25)
View(last)
