
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 																	Implicit D-Matrices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\ALGstochrow}{
	\begin{algorithm}[Stochastic Row] \hfill
	\begin{enumerate}
		\item To sample a row $r$ of size $N$, fix $N \in \N$.
		\item Sample a vector $\vec{X}$ with $N$ i.i.d entries between $[0,1]$. So, sample $\vec{X} \sim \Unif(0,1)$.
		\item Assign $r \la \vec{X}$, and then normalize the row by diving each entry by the row sum; so assign $r \la r \cdot \frac{1}{\sum_{j = 1}^N{r_j}}$
		\item Return the stochastic row $r$.
	\end{enumerate}
	\end{algorithm}
}

\newcommand{\ALGstoch}{
	\begin{algorithm}[Stochastic Matrix] \hfill
	\begin{enumerate}
		\item To generate a stochastic square matix $P$ of size $N \times N$, fix $N \in \N$.
		\item Then, for every row of $P$, randomly sample a stochastic row of size $N$ and assign it.
		\item Return the stochastic matrix $P$.
	\end{enumerate}
	\end{algorithm}
}

\newcommand{\ALGstochsymm}{
	\begin{algorithm}[Symmetric Stochastic Matrix] \hfill
	\begin{enumerate}
		\item To sample a symmetric stochastic matrix $P$ of size $N$, fix $N \in \N$.
		\item Sample a random stochastic matrix $Q$ of size $N$.
		\item Choosing one of the triangles of $Q$, set both the upper and lower of triangles of $P$ to be that triangle.
		\item Set the diagonal of the matrix $P$ to be equal to 1 minus the sum of the non-diagonal entries.
		\item Return the symmetric stochastic matrix $P$.
	\end{enumerate}
	\end{algorithm}
}

\newcommand{\ALGerdos}{
	\begin{algorithm}[Transition Matrix for an Erdos-Renyi Graph] \hfill
	\begin{enumerate}
		\item{Fix $N \in \N$ and $p \in [0,1]$}.
		\item{Generate a matrix $Q \sim \Unif(0,1)$, i.e. with randomly uniform entries on [0,1].}
		\item{For each row $r$ in $\{1,\dots,N\}$, generate $deg(r) \sim \Bin(N,p)$.}
		\item{Randomly chose $N-deg(r)$ vertices, set the entries $r_{j}$ in the $j$ columns to 0 to sever them.}
		\item{Renormalize the matrix by dividing each row by its sum; let $(r) \leftarrow (r)/\sum_{j=1}^N(r_j)$}.
	\end{enumerate}
	\end{algorithm}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 																	Explicit D-Matrices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\ALGexplicit}{
	\begin{algorithm}[Homogenous Explicit $\D$-Matrix] \hfill
	\begin{enumerate}
		\item To simulate a $\D$-distributed square matrix $P$ of size $N$, fix $N \in \N$.
		\item Sample a vector $\vec{X}$ with $N$ i.i.d entries from $\D$. %So, generate $\vec{X} = X_1,\dots,X_N \where X_i \text{is i.i.d } \D$.
		\item Assign the vector $\vec{X}$ as a row of the matrix $P$. Repeat for every other row.
		\item Return the $\D$-distributed matrix $P$.
	\end{enumerate}
	\end{algorithm}
}

\newcommand{\ALGbeta}{
  \begin{algorithm}[Dumitriu's Beta Matrix] \hfill
    \begin{enumerate}
      \item To simulate an $N \times N$ beta matrix, fix $N \in \N$.
      \item Start by taking a diagonal of $\Normal(0,2)$ variables.
      \item Set both of the nearest off-diagonals to the row that samples from a $\chi(df = c_j) \where c_j = \beta \cdot j$ for columns spanning $j = 1,\dots,N-1$.
			\item Normalize the entries by dividing by $\sqrt{2}$.
    \end{enumerate}
  \end{algorithm}
}

\newcommand{\ALGbetaunnum}{
  \begin{algorithm*}[Dumitriu's Beta Matrix] \hfill
    \begin{enumerate}
      \item To simulate an $N \times N$ beta matrix, fix $N \in \N$.
      \item Start by taking a diagonal of $\Normal(0,2)$ variables.
      \item Set both of the nearest off-diagonals to the row that samples from a $\chi(df = c_j) \where c_j = \beta \cdot j$ for columns spanning $j = 1,\dots,N-1$.
			\item Normalize the entries by dividing by $\sqrt{2}$.
    \end{enumerate}
  \end{algorithm*}
}
