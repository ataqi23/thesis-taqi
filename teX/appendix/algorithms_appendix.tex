
\chapter{Algorithm Appendix}

In this appendix, we will enumerate the various algorithms used in this thesis for the purpose of transparency and reproducibility. Every one of these algorithms have their code counterpart in the $\RMAT$ package. For the most part, the implicit $\D$-matrices are the non-trivial algorithms to peruse. Changing methodology could impact results, and as such, all results are tied to the algorithms in this appendix.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implicit $\D$-Matrices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[Stochastic Row] \hfill
\begin{enumerate}
	\item To sample a row of size $N$, fix $N \in \N$.
	\item Sample a vector $X$ with $N$ entries between $[0,1]$. So, generate $X = (x_i)_{i = 1}^N \where x_i \sim \Unif(0,1)$.
	\item Normalize the rows by diving each entry by the row sum; so assign $x_i \la x_i \cdot \frac{1}{\sum{x_i}}$
	\item Return the stochastic row $X$.
\end{enumerate}
\end{algorithm}

\begin{algorithm}[Stochastic Matrix] \hfill
\begin{enumerate}
	\item To generate a stochastic square matix $P$ of size $N$, fix $N \in \N$.
	\item Then, for every row of $P$, randomly sample a stochastic row and assign it to $P$.
	\item Return the stochastic matrix $P$.
\end{enumerate}
\end{algorithm}

\begin{algorithm}[Symmetric Stochastic Matrix] \hfill
\begin{enumerate}
	\item To sample a symmetric stochastic matrix $P$ of size $N$, fix $N \in \N$.
	\item Sample a random stochastic matrix $Q$ of size $N$.
	\item Choosing one of the triangles of $Q$, set both the upper and lower of triangles of $P$ to be that triangle.
	\item Set the diagonal of the matrix $P$ to be equal to 1 minus the sum of the non-diagonal entries.
	\item Return the symmetric stochastic matrix $P$.
\end{enumerate}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[Transition Matrix of an Erdos-Renyi Graph] \hfill
\begin{enumerate}
	\item{Fix $N \in \N$ and $p \in [0,1]$}.
	\item{Generate a matrix Q such that every entry $i,j\in \oneto[N]$ is $x_{ij} \sim \Unif(0,1)$.}
	\item{For each $v_i$ in $\{1,\dots,N\}$, generate $deg(v_i) \sim \Bin(N,p)$.}
	\item{Randomly chose $1-deg(v_i)$ vertices, set the entries $x_{ij}$ in the $j$ columns to 0.}
	\item{Renormalize the matrix by dividing each row by its sum; let $(x_i) \leftarrow (x_i)/\sum_j(x_i)$}.
\end{enumerate}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Explicit $\D$-Matrices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[Explicit $\D$-Matrix] \hfill
\begin{enumerate}
	\item To simulate a $\D$-distributed square matrix $P$ of size $N$, fix $N \in \N$.
	\item Sample a vector $X$ with $N$ entries from $\D$. So, generate $X = (x_i)_{i = 1}^N \where x_i \sim \D$.
	\item Assign the vector $X$ as a row of the matrix $P$. Repeat for every other row.
	\item Return the $\D$-distributed matrix $P$.
\end{enumerate}
\end{algorithm}

\dumitriuALGORITHM

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
